(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6928],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,h=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2580:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),s=["components"],i={sidebar_position:2},c="Develop Contract",l={unversionedId:"develop-smart-contract/develop",id:"develop-smart-contract/develop",isDocsHomePage:!1,title:"Develop Contract",description:"In this session, we will build on top of the template we generated on the previous page.",source:"@site/i18n/fr/docusaurus-plugin-content-docs-dev-academy/current/develop-smart-contract/02-develop.md",sourceDirName:"develop-smart-contract",slug:"/develop-smart-contract/develop",permalink:"/fr/dev-academy/develop-smart-contract/develop",editUrl:"https://crowdin.com/project/cosmwasm-docs/fr",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"devAcademy",previous:{title:"Anatomy of A Smart Contract",permalink:"/fr/dev-academy/develop-smart-contract/intro"}},d=[{value:"Config",id:"config",children:[]},{value:"Instantiate",id:"instantiate",children:[{value:"Msg",id:"msg",children:[]},{value:"Execute",id:"execute",children:[]},{value:"Tests",id:"tests",children:[]}]},{value:"Create Pot",id:"create-pot",children:[{value:"State",id:"state",children:[]},{value:"Msg",id:"msg-1",children:[]},{value:"Execute",id:"execute-1",children:[]}]},{value:"Collect Tokens",id:"collect-tokens",children:[]},{value:"Summary",id:"summary",children:[]},{value:"Challenge",id:"challenge",children:[]}],p={toc:d};function u(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"develop-contract"},"Develop Contract"),(0,o.kt)("p",null,"In this session, we will build on top of the template we generated on the previous ",(0,o.kt)("a",{parentName:"p",href:"/fr/dev-academy/develop-smart-contract/intro"},"page"),"."),(0,o.kt)("p",null,"Here is the application logic we want:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Collected tokens in smart contract's balance are released to a target address after the token amount exceeds a specified amount."),(0,o.kt)("li",{parentName:"ul"},"Contract accepts cw20 token that is predefined by the admin.")),(0,o.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"We recommend deleting boilerplate code during implementation to help with copying and pasting code. :::")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"})),(0,o.kt)("h2",{id:"config"},"Config"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"admin")," information which determines who has pot creation address must be persisted on contract storage during each execution. We will save this information to the storage on ",(0,o.kt)("inlineCode",{parentName:"p"},"Instantiate")," phase."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Config {\n  pub admin: Addr,\n  pub cw20_addr: Addr\n}\n\npub const CONFIG: Item<Config> = Item::new("config");\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Item")," is used since this data will be a singleton."),(0,o.kt)("h2",{id:"instantiate"},"Instantiate"),(0,o.kt)("h3",{id:"msg"},"Msg"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct InstantiateMsg {\n    pub admin: Option<String>,\n    /// cw20_addr is the address of the allowed cw20 token\n    pub cw20_addr: String\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"admin")," is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," because if ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"info.sender")," will be set as admin. The accepted cw20 address is set here."),(0,o.kt)("h3",{id:"execute"},"Execute"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cfg_attr(not(feature = "library"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> Result<Response, ContractError> {\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n\n    let owner = msg.admin\n        .and_then(|s| deps.api.addr_validate(s.as_str()).ok())\n        .unwrap_or(info.sender);\n    let config = Config {\n        owner: owner.clone(),\n    };\n    let config = Config {\n        owner: owner.clone(),\n        cw20_addr: deps.api.addr_validate(msg.cw20_addr.as_str())?\n    };\n    CONFIG.save(deps.storage, &config);\n\n    // init pot sequence\n    POT_SEQ.save(deps.storage, &Uint128::new(0))?;\n\n    Ok(Response::new()\n        .add_attribute("method", "instantiate")\n        .add_attribute("owner", owner)\n        .add_attribute("cw20_addr", msg.cw20_addr))\n}\n')),(0,o.kt)("p",null,"The logic above is for if the owner is ",(0,o.kt)("inlineCode",{parentName:"p"},"Some")," validate, if not use ",(0,o.kt)("inlineCode",{parentName:"p"},"info.sender")," and store configuration, then return ",(0,o.kt)("inlineCode",{parentName:"p"},"Response")," with attributes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"let owner = msg.admin\n    .and_then(|s| deps.api.addr_validate(s.as_str()).ok())\n    .unwrap_or(info.sender);\n")),(0,o.kt)("p",null,"The example above is a great one to understand method chaining. Great read: ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/error/option_unwrap/and_then.html"},"Rust Combinator")),(0,o.kt)("h3",{id:"tests"},"Tests"),(0,o.kt)("p",null,"I leave this part to you as a challenge ;)"),(0,o.kt)("h2",{id:"create-pot"},"Create Pot"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"admin")," can create pots to collect money in with a given threshold."),(0,o.kt)("h3",{id:"state"},"State"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\npub struct Pot {\n  /// target_addr is the address that will receive the pot\n  pub target_addr: Addr,\n  /// threshold_amount is the token threshold amount\n  pub threshold_amount: Uint128,\n  /// collected keeps information on how much is collected for this pot.\n  pub collected: Uint128,\n}\n\n/// POT_SEQ holds the last pot ID\npub const POT_SEQ: Item<Uint128> = Item::new("pot_seq");\n/// POTS are indexed my an auto incremented integer number.\npub const POTS: Map<U128Key, Pot> = Map::new("pot");\n')),(0,o.kt)("p",null,"We can use a ",(0,o.kt)("inlineCode",{parentName:"p"},"save_pot")," helper to auto-increment seq and use it as an index for pot."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn save_pot(deps: DepsMut, pot: &Pot) -> StdResult<()> {\n  // increment id if exists, or return 1\n  let id = POT_SEQ.load(deps.storage)?;\n  // checks for overflow\n  let id = id.checked_add(Uint128::new(1))?;\n  POT_SEQ.save(deps.storage, &id)?;\n\n  // save pot with id\n  POTS.save(deps.storage, id.u128().into(), pot)\n}\n")),(0,o.kt)("h3",{id:"msg-1"},"Msg"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ExecuteMsg")," becomes this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ExecuteMsg {\n    CreatePot {\n        /// target_addr will receive tokens when token amount threshold is met.\n        target_addr: String,\n        /// threshold is the token amount for releasing tokens.\n        threshold: Uint128\n    },\n}\n')),(0,o.kt)("h3",{id:"execute-1"},"Execute"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Execute")," becomes this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn execute_create_pot(\n    deps: DepsMut,\n    info: MessageInfo,\n    target_addr: String,\n    threshold: Uint128,\n) -> Result<Response, ContractError> {\n    // owner authentication\n    let config = CONFIG.load(deps.storage)?;\n    if config.owner != info.sender {\n        return Err(ContractError::Unauthorized {});\n    }\n    // create and save pot\n    let pot = Pot {\n        target_addr: deps.api.addr_validate(target_addr.as_str())?,\n        threshold,\n        collected: Uint128::zero(),\n        ready: false,\n    };\n    save_pot(deps, &pot)?;\n\n    Ok(Response::new()\n        .add_attribute("action", "execute_create_pot")\n        .add_attribute("target_addr", target_addr)\n        .add_attribute("threshold_amount", threshold))\n}\n')),(0,o.kt)("h2",{id:"collect-tokens"},"Collect Tokens"),(0,o.kt)("p",null,"This is the important part that this document tries to teach: Interaction with an external contract. The smart contract will collect cw20 tokens. After cw20 token is sent, this contract will operate on this information."),(0,o.kt)("p",null,"But how?"),(0,o.kt)("p",null,"CosmWasm smart contracts work as message-sending actors. Each contract execute other via sending a message back to the context."),(0,o.kt)("p",null,"Users can transfer tokens from their account to the smart contract, then execute the smart contract to save this token allocation in the next TX. But the problem here is how to verify this token is sent from this user?"),(0,o.kt)("p",null,"One way to achieve this:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"User ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/CosmWasm/cw-plus/tree/main/packages/cw20#allowances"},"increases token allowance")," of the cw20-pot smart contract address."),(0,o.kt)("li",{parentName:"ol"},"User triggers cw20-pot contract to withdraw allowed funds to its account.")),(0,o.kt)("p",null,"This operation requires two transactions."),(0,o.kt)("p",null,"There is a better and elegant way: ","[","cw20 Receiver Interface","]","(",(0,o.kt)("a",{parentName:"p",href:"https://github."},"https://github.")," com/CosmWasm/cw-plus/tree/main/packages/cw20#receiver)."),(0,o.kt)("p",null,"Works like this, the user creates a message for sending cw20 tokens to cw20-pot contract with an embedded message inside to trigger cw20-pot execution."),(0,o.kt)("p",null,"If you check ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-plus/blob/main/contracts/cw20-base/src/contract.rs#L318"},"cw20-base/contracts.rs#execute_send")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn execute_send(\n  deps: DepsMut,\n  _env: Env,\n  info: MessageInfo,\n  contract: String,\n  amount: Uint128,\n  msg: Binary,\n) -> Result<Response, ContractError> {\n")),(0,o.kt)("p",null,"In the signature, you will notice ",(0,o.kt)("inlineCode",{parentName:"p"},"contract"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"msg"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"contract")," is the recipient of the token and also address of the next execution, ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," is the number of tokens and ",(0,o.kt)("inlineCode",{parentName:"p"},"msg")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"base64")," external message."),(0,o.kt)("p",null,"At the end of ",(0,o.kt)("inlineCode",{parentName:"p"},"execute_send"),", you will see a ",(0,o.kt)("inlineCode",{parentName:"p"},"Response")," with an embedded message sent back to the chain."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let res = Response::new()\n        .add_attribute("action", "send")\n        .add_attribute("from", &info.sender)\n        .add_attribute("to", &contract)\n        .add_attribute("amount", amount)\n        .add_message(\n            Cw20ReceiveMsg {\n                sender: info.sender.into(),\n                amount,\n                msg,\n            }\n            .into_cosmos_msg(contract)?,\n        );\n    Ok(res)\n')),(0,o.kt)("p",null,"As you can see ",(0,o.kt)("inlineCode",{parentName:"p"},"msg")," is wrapped in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Cw20ReceiveMsg")," and for contract-cw20 interaction, your contract accept ",(0,o.kt)("inlineCode",{parentName:"p"},"Cw20ReceiveMsg"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn execute_receive(\n  deps: DepsMut,\n  info: MessageInfo,\n  wrapped: Cw20ReceiveMsg,\n) -> Result<Response, ContractError> {\n  // cw20 address authentication\n  let config = CONFIG.load(deps.storage)?;\n  if config.cw20_addr != info.sender {\n    return Err(ContractError::Unauthorized {});\n  }\n\n  let msg: ReceiveMsg = from_binary(&wrapped.msg)?;\n  match msg {\n    ReceiveMsg::Send { id } => receive_send(deps, id, wrapped.amount, info.sender),\n  }\n}\n")),(0,o.kt)("p",null,"On this line, contract-defined embed receive msg is parsed from base64 binary."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"  let msg: ReceiveMsg = from_binary(&wrapped.msg)?;\n")),(0,o.kt)("p",null,"Here is the ",(0,o.kt)("inlineCode",{parentName:"p"},"ReceiveMsg"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum ReceiveMsg {\n    // Send sends token to an id with defined pot\n    Send { id: Uint128 },\n}\n')),(0,o.kt)("p",null,"It creates a second depth branch inside ",(0,o.kt)("inlineCode",{parentName:"p"},"execute"),"."),(0,o.kt)("p",null,"And the smart contract runs this logic:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn receive_send(\n    deps: DepsMut,\n    pot_id: Uint128,\n    amount: Uint128,\n    cw20_addr: Addr,\n) -> Result<Response, ContractError> {\n    // load pot\n    let mut pot = POTS.load(deps.storage, pot_id.u128().into())?;\n\n    pot.collected += amount;\n\n    POTS.save(deps.storage, pot_id.u128().into(), &pot)?;\n\n    let mut res = Response::new()\n        .add_attribute("action", "receive_send")\n        .add_attribute("pot_id", pot_id)\n        .add_attribute("collected", pot.collected)\n        .add_attribute("threshold", pot.threshold);\n\n    // if collected exceeds threshold prepare a cw20 message\n    if pot.collected >= pot.threshold {\n        let cw20 = Cw20Contract(cw20_addr);\n        let msg = cw20.call(Cw20ExecuteMsg::Transfer {\n            recipient: pot.target_addr.into_string(),\n            amount: pot.collected,\n        })?;\n        res = res.add_message(msg);\n    }\n\n    Ok(res)\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    // if collected exceeds threshold prepare a cw20 message\n    if pot.collected >= pot.threshold {\n        // Cw20Contract is a function helper that provides several queries and message builder.\n        let cw20 = Cw20Contract(cw20_addr);\n        // Build a cw20 transfer send msg, that send collected funds to target address\n        let msg = cw20.call(Cw20ExecuteMsg::Transfer {\n            recipient: pot.target_addr.into_string(),\n            amount: pot.collected,\n        })?;\n        res = res.add_message(msg);\n    }\n")),(0,o.kt)("p",null,"After the execution, if the threshold is passed, the collected amount is sent to the target."),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"In this section, we showed you contract to contract interaction and cw20 contract interaction. This should give you some insight to message passing, Actor model, and contract development."),(0,o.kt)("h2",{id:"challenge"},"Challenge"),(0,o.kt)("p",null,"As a challenge, you can try to implement a contract that extends ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cosmwasm-plus/"},"cw-plus")," or ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/cw-nfts"},"cw-nfts"),"."))}u.isMDXComponent=!0}}]);